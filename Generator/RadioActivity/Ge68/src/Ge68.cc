///This is the Ge68 positron/gamma generator, in effect a Ga68 generator.
///- Ge68 decays into Ga68 (270 days) solely via electron capture.
///- Ga68 decays into Zn68 (68 minutes) via both electron capture 
///  and beta+ decay
///- The Zn68 also has a 1st excited state of 1.07 MeV
///- The K/L gammas from electron capture and the conversion electrons will 
///  be omitted (too low energy or intensity). 
///- However the 1.07 MeV gamma ray will need to be taken into Account.
///The important thing is to get the beta+ to EC ratio correct for the 
///Zn68 ground state and the 1st excited 
///A combination of NNDC ENSDF Decay Search and Nudat databases 
///give the following info
///G.S. beta+: 
///     (87.94%, Q=1899.1 keV), EC (8.70%, gammas omitted)
///1st excited states: 
///     (1.20%, Q=821.8 keV, Egamma=1077.35 keV), EC(1.79%, Egamma=1077.35 keV)
///Others cascades that pass the 1st excited states:
///     3.22%-1.79-1.20%=0.23%, Egamma=1077.35 keV
///Note the beta+ and gamma correlation for the 1st excited states

#include <stdio.h>
#include <iostream>
#include <cassert>

#include <CLHEP/Vector/ThreeVector.h>
#include <CLHEP/Random/Randomize.h>
#include <CLHEP/Units/PhysicalConstants.h>
#include <TRandom.h>
#include <TMath.h>
#include <TF1.h>
#include <TH1.h>

using namespace std;
using namespace CLHEP;

//a few hard-coded constants
const double electronMass = 0.510998910e-3; //in GeV 
const double Q_gs = 1.8991e-3; //in GeV
const double Q_1st = 0.8218e-3; //in GeV
const double E_gamma = 1.07735e-3; //in GeV

Double_t dNdE(Double_t *x, Double_t *par)
{
  // par[0] is the Q value in GeV
  // x[0] is electron energy with unit GeV
  Double_t KE = x[0];
  Double_t Q = par[0];

  Double_t Energy = KE + electronMass;
  Double_t p = sqrt(KE*(KE+2*electronMass));

  Double_t spec = (Q-KE)*(Q-KE)*Energy*p;
  return spec;
}

void ProcessArgs(int argc, char** argv, long* rseed, char** outfilename, 
                 unsigned int* nevents, int* geom );
void Usage(char* name);

int main(int argc, char** argv) {
  long rseed = 0;
  char* outFilename = NULL;
  unsigned int nEvents = 1000000000; // a billion. Default to something big for piping 
  // geom:
  // * 0 -> no geom, normal spectrum 
  // * 1 -> Ek(e+) = 0, only gamma 
  int geom = 0; 
  ProcessArgs(argc, argv, &rseed, &outFilename, &nEvents, &geom);
  
  FILE* stream = stdout;
  if( outFilename!=NULL ) {
    stream = fopen(outFilename, "w");
    if( stream==NULL ) {
      printf("Please enetr a valid filename.\n");
      Usage(argv[0]);
      exit(0);
    }
  }

  gRandom->SetSeed(rseed);

  //create beta spectrum function
  TF1* funcBetaEnergy_gs = new TF1("funcBetaEnergy_gs", dNdE, 0., Q_gs, 1);//GeV
  funcBetaEnergy_gs->SetParameter(0, Q_gs);//Q value in GeV for G.S.
  TF1* funcBetaEnergy_1st = new TF1("funcBetaEnergy_1st", dNdE, 0., Q_1st, 1);//GeV
  funcBetaEnergy_1st->SetParameter(0, Q_1st);


  //HepRandom::setTheSeed(rseed);
  //start by printing some information to comment lines
  fprintf(stream, "# File generated by %s.\n", argv[0]);
  fprintf(stream, "# Random seed for generator = %ld.\n", rseed);
  


  //create a branch weighting table for random sampling
  TH1I *hBranching = new TH1I("hBranching","", 3, 0, 3);
  //See notes at the beginning of the code for the prob values below
  hBranching->SetBinContent(1,87.94);
  hBranching->SetBinContent(2,1.20);
  hBranching->SetBinContent(3,2.02);//lump EC 1st excited state with other cascade
  
  for( size_t i=0 ; i<nEvents ; i++ ) {
    Int_t ibranch = hBranching->FindBin(hBranching->GetRandom());
    double energyInGeV(0.0), momentumInGeV(0.0);
    double px = 0.0, py = 0.0, pz = 0.0;
    double phi = 0.0, theta = 0.0;
    
    if(ibranch==1){//ground state positron emission
      energyInGeV=funcBetaEnergy_gs->GetRandom();
      momentumInGeV = TMath::Sqrt(energyInGeV*energyInGeV
                                  +2.0*electronMass*energyInGeV);      
      phi= gRandom->Uniform(0.0,2.0*TMath::Pi());
      theta= acos(gRandom->Uniform(-1.0,1.0));

      if (geom == 1) {
        momentumInGeV = 0.0;
      }

      px = cos(phi)*sin(theta)*momentumInGeV;
      py = sin(phi)*sin(theta)*momentumInGeV;
      pz = cos(theta)*momentumInGeV;

      fprintf(stream, "1\n");
      fprintf(stream, "1\t-11 0 0 %e %e %e %e\n", px, py, pz, electronMass); 

    } else if (ibranch==2) {//1st excited state, positron emission
      energyInGeV=funcBetaEnergy_1st->GetRandom();
      momentumInGeV = TMath::Sqrt(energyInGeV*energyInGeV
                                  +2.0*electronMass*energyInGeV);      
      phi= gRandom->Uniform(0.0,2.0*TMath::Pi());
      theta= acos(gRandom->Uniform(-1.0,1.0));

      if (geom == 1) {
        momentumInGeV = 0.0;
      }

      px = cos(phi)*sin(theta)*momentumInGeV;
      py = sin(phi)*sin(theta)*momentumInGeV;
      pz = cos(theta)*momentumInGeV;

      fprintf(stream, "2\n");
      fprintf(stream, "1\t-11 0 0 %e %e %e %e\n", px, py, pz, electronMass);      
      //now do the gamma, assuming no angular correlation with e+
      phi= gRandom->Uniform(0.0,2.0*TMath::Pi());
      theta= acos(gRandom->Uniform(-1.0,1.0));
      
      px = cos(phi)*sin(theta)*E_gamma;
      py = sin(phi)*sin(theta)*E_gamma;
      pz = cos(theta)*E_gamma;
      
      fprintf(stream, "1\t22 0 0 %e %e %e 0\n", px, py, pz); 
    } else if (ibranch==3) {//single gamma emission
      phi= gRandom->Uniform(0.0,2.0*TMath::Pi());
      theta= acos(gRandom->Uniform(-1.0,1.0));
      
      px = cos(phi)*sin(theta)*E_gamma;
      py = sin(phi)*sin(theta)*E_gamma;
      pz = cos(theta)*E_gamma;
      fprintf(stream, "1\n");
      fprintf(stream, "1\t22 0 0 %e %e %e 0\n", px, py, pz);
    }
    else {
      cout<<"Wrong branch ID. Ignored ..."<<endl;
    }
  }
  return 0;
}


void ProcessArgs(int argc, char** argv, long *rseed, 
                 char** outfilename, unsigned int* nevents,
                 int* geom) {
  int i;
  for( i=1 ; i<argc ; i++ ) {
    if( strcmp(argv[i], "-seed")==0 ) {
      i++; assert(i<argc);
      sscanf(argv[i], "%ld", rseed);
    } else if( strcmp(argv[i], "-o")==0 ) {
      i++; assert(i<argc);
      *outfilename = new char[strlen(argv[i]) +1];
      strcpy(*outfilename, argv[i]);
    } else if( strcmp(argv[i], "-n")==0 ) { 
      i++; assert(i<argc);
      sscanf(argv[i], "%ud", nevents);
    } else if (strcmp(argv[i], "-geom")==0) {
      i++; assert(i<argc);
      sscanf(argv[i], "%d", geom);
    } else {
      Usage(argv[0]);
      exit(0);
    }
  }
}

void Usage(char* name) {
  printf("%s [-seed seed] [-o outputfilename] [-n nevents] [-geom geom]\n", name);
}

